# 빌트인 객체

# 🤖 표준 빌트인 객체

표준 빌트인 객체는 ECMAScript 사양에 정의된 객체를 말한다. ECMAScript 에서 정의한 객체여서 실행환경(브라우저, node.js)에 관계없이 언제나 사용가능하다.

표준 빌트인 객체는 전역 객체 프로퍼티로 제공이 되어서 별도 선언없이 사용이 가능하다.

40개의 표준 빌트인 객체가 있다. 40개 중 3개 Math, Reflect, JSON을 제외한 나머지 표준 빌트인 객체는 생성자 함수이다. 따로 인스턴스를 생성할 수있다.

| 표준 빌트인 객체 이름         | 제공하는 기능                                    |
| ----------------------------- | ------------------------------------------------ |
| Math, Reflect, JSON           | 비 생성자 함수, 정적 메소드 제공                 |
| Math, Reflect, JSON 외 나머지 | 생성자 함수, 프로토타입 메소드, 정적 메소드 제공 |

```jsx
// 생성자 함수로 생성된 인스턴스는 obj 타입이다.
const strObj = new String("lee");
console.log(typeof strObj); // object

const numObj = new Number(1);
console.log(typeof numObj); // object
```

생성자 함수로 생성한 인스턴스는 타입이 object이다.

```jsx
console.log(strObj.__proto__ === String.prototype); // true
console.log(numObj.__proto__ === Number.prototype); // true
```

생성자 함수로 만든 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.

```jsx
const numObj = new Number(1.2);
console.log(numObj); // [Number: 1.2]
// 인스턴스 프로토타입이
// 빌트인 객체 프로토타입에 바인딩되어서 빌트인 프로토타입 메서드
// 를 사용할 수 있다.
console.log(numObj.toFixed(1)); // 1.2

// 빌트인 정적 메서드
console.log(Number.isInteger(1.5)); // false
```

인스턴스는 빌트인 프로토타입 메서드를 제공 받고 사용할 수 있다. 표준 빌트인 객체는 인스턴스 생성 없이 바로 호출할 수 있는 빌트인 정적 메서드도 제공해준다.

---

# 🙉 원시값과 래퍼 객체

```jsx
const str = "hi";

console.log(str.length); // 2
console.log(str.toUpperCase()); // HI
// 래퍼 객체 이용이 끝났다면 다시 원시값으로 돌아온다.
console.log(typeof str); // string
```

문자열, 숫자, 불리언 등 원시값이 있는데도 생성자 함수를 제공하고 인스턴스를 생성하는 이유가 무엇인지 알아보자.

원시값은 참조타입이 아니여서 프로퍼티나 메서드를 가질수 없는데 위에 코드처럼 메서드나 프로퍼티를 사용한다.

원시값에 대해 객체처럼 마침표 표기법으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해준다.

원시값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라고 한다.

래퍼 객체는 표준 빌트인 객체 프로토타입 메서드를 상속 받는다.

그래서 표준 빌트인 객체의 프로퍼티나 프로토타입 메서드를 이용할 수 있는 것이다. 이용이 끝났다면 자바스크립트 엔진은 다시 원시값으로 돌려놓는다.

래퍼 객체로 만들어지면 원시값은 래퍼 객체 내부 슬롯에 할당된다. string 원시값으로 예를 들면 래퍼 객체로 만들어지면 [[StringDate]] 내부 슬롯에 할당된다.

![                                         문자열 래퍼 객체의 프로토타입 체인](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/636e9713-635a-440c-ba06-b13bbdcdbbb6/rapper1.jpg)

                                         문자열 래퍼 객체의 프로토타입 체인

```jsx
const str = "hello";
// 래퍼 객체가 만들어지고 객체 name 프로퍼티에 lee가 할당된다.
str.name = "lee";
// 원시값으로 돌아오고 래퍼 객체는 가비지 콜렉션이 제거한다.

// 래퍼 객체 name 프로퍼티에 접근하지만 이전 래퍼 객체는 제거되고
// 새로운 래퍼 객체에 name 프로퍼티는 존재하지 않는다.
console.log(str.name); // undefined
```

원시값으로 돌아가면 래퍼 객체는 가비지 콜렉션에 대상이 된다.

원시값일때도 표준 빌트인 객체 프로토타입 메서드 호출이 가능하다. 그래서 new 연산자를 통해서 인스턴스를 생성할 필요도 없고 권장되지도 않는다.

null, undefined도 원시값이지만 두개는 래퍼 객체를 생성하지않는다. 두개 원시값을 객체처럼 사용하면 에러가 발생한다.

---

# 🙋🏻‍♂️ 전역 객체

전역 객체는 런타임 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체다. 어떤 객체에도 속하지 않는 최상위 객체다.

자바스크립트 환경에 따라 전역 객체 이름은 다르다.

1. 브라우저
   1. window
   2. this
   3. self
   4. frames
2. node.js
   1. global

다양한 이름이 전역 객체를 가리킨다.

<aside>
📌 **ES11**에서 도입된 globalTihs라는 개념이 있다. 자바스크립트 환경에 상관없이 최상위 객체 전역 객체를 가리키는 식별자다. 
globalThis === window // true 브라우저 환경
globalThis === global // true  노드 환경

</aside>

전역 객체는 표준 빌트인 객체, 환경에 따른 호스트 객체, var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.

전역 객체는 계층적 구조상 어느 객체에도 속하지 않는 모든 빌트인 객체에 최상위 객체다. 전역 객체가 어느 객체의 프로퍼티가 아니며 전역 객체의 프로퍼티로 표준 빌트인 객체와 호스트 객체를 소유한다는 것이다.

**전역 객체의 특징**

- 개발자가 의도적으로 생성할 수 없다. 생성자 함수가 제공되지 않는다.
- 전역 객체의 프로퍼티를 참조할 때 전역 객체(window, global)를 생략할 수 있다.

```jsx
window.parseInt("F", 16); // 15
parseInt("F", 16); // 15
window.parseInt === parseInt; // true
```

전역 객체를 생략하고 함수를 호출할 수 있다.

```jsx
x = 10;
window.x; // 10
var xx = 1;
window.xx; // 1
```

var키워드로 선언하거나 키워드 없는 변수에 할당하면 암묵적 전역상태가 되고 전역 객체 프로퍼티가 된다.

### 빌트인 전역 프로퍼티

❗ **사용 법은 따로 정리하지 않을 것이다. 우린 전역 프로퍼티로 무엇이있는지만 알고 넘어간다.**

1. Infinity : Infinity프로퍼티는 무한대를 나타내는 숫자값 Infinity를 갖는다.
2. NaN : 숫자가 아님을 나타내는 숫자값 NaN를 갖는다.
3. undefined : 원시 타입 undefined를 값으로 갖는다.

### 빌트인 전역 함수

❗ **사용 법은 따로 정리하지 않을 것이다. 우린 전역 프로퍼티로 무엇이있는지만 알고 넘어간다.**

빌트인 전역 함수는 애플리케이션 전역에서 호출할 수 있는 함수로서 전역 객체의 메서드이다.

1. eval : eval함수 호출 시 인수로 넘긴 문자열 코드를 런타임에 실행되도록 해준다. eval함수 사용은 금지되고 있다. 어떤 함수인지 알고만 있자.
2. isFinite : 전달 받은 인수가 정상적인 유한수인지 검사하여 유한수면 true 무한수면 false를 반환한다. 숫타가 아닌 타입은 숫자 타입으로 형변환 후 검사한다. NaN으로 평가된 값은 false를 준다.
3. isNaN : 전달 받은 인수가 NaN인지 검사하여 결과값으로 불리언 타입을 준다. 숫자가 아닌 타입은 형변환 후 검사한다.
4. parseFloat : 문자열 인수를 받아 실수로 해석하여 반환한다.
5. parseInt : 문자열 인수를 받아 정수로 해석하여 반환한다.
6. encodeURI / decodeURI : 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다. 이스케이프 처리된 URI를 다시 이전으로 돌리기위해 사용한다.
7. encodeURIComponent / decodeURIComponent : encodeURI는 =, ?, &은 인코딩 하지않지만 encodeURIComponent는 =, ?, &까지 인코딩을 진행한다. [참고](https://androman.tistory.com/27)

<aside>
📌 **인코딩이란?**
어떤 네트워크에서도 사용할 수 있게 문자를 코드(ASCII,유니코드 등)로 변환하는 것
**이스케이프 처리란?**
네트워크를 통해 정보를 공유할때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것을 말한다.

</aside>

### 암묵적 전역

```jsx
var x = 10;
function foo() {
  y = 20;
}
foo();

console.log(x + y);
```

var 키워드로 선언하거나 선언하지 않은 식별자에 값을 할당하면 전역 객체 프로퍼티가 된다. 이 현상을 암묵적 전역이라고 한다.

⭐ 이때 var키워드는 호이스팅 되지만 선언되지 않은 식별자는 호이스팅이 안된다. 단지 전역 객체 프로퍼티에 추가되었을 뿐이다.

```jsx
var x = 10;
y = 20;

delete window.x; // false
delete window.y; // true
```

⭐ 전역 변수는 delete 연산자로 삭제가 안되지만 전역 객체 프로퍼티는 삭제가 가능하다.
