# 클로저

클로저라는 개념은 자바스크립 고유의 개념이 아니다. 함수를 일급객체로 취급하는 함수형 프로그래밍언어에서 사용되는특성이다.

---

> **일급객체**
>
> 1. 리터럴로 생성이 가능해야된다. 런타임에 생성이 가능하다는 걸 의미한다.
> 2. 함수의 인자로 넘길 수 있어야 된다.
> 3. 함수의 리턴 값으로 사용 할 수 있어야된다.
> 4. 변수, 자료구조에 할당 할 수 있어야된다.

그래서 **클로저란?.**

---

> 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

여기서 핵심은 함수가 선언된 렉시컬환경이다. 아직 잘모르겠다. 예제를 보면서 이해해보자.

```jsx
const x = 1;

function foo() {
  const x = 10;
  bar();
}
function bar() {
  console.log(x);
}

foo(); // undefined
bar(); // 10
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/946a29d7-f5be-4957-b72d-dabba2554f7f/Untitled.png)

foo,bar의 실행컨텍스트

자바스크립트의 **렉시컬 스코프(정적스코프)**

자바스크립트 엔진은 함수가 어디서 호출 됬는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정하는 특성이있다.

위에 예제를 보면서 이해해보자.

1. foo와 bar는 둘 다 전역에 선언 되어있다. 렉시컬 스코프에 특성에 따라 상위스코프를 전역을 가지게된다.
2. foo 함수 내부에서 bar를 호출하여도 bar의 스코프 기준에서 x를 찾고 자신 스코프에 x 변수를 참조 할 수 없으니 상위스코프(전역)으로 올라가서 x를 찾게되어서 10을 출력하게된다.

**상위 스코프는 어떻게 찾는가?**

> **외부 렉시컬 환경참조(Outer Lexical Environment Reference) OER**
>
> 상위 스코프에 대한 참조는 각각의 스코프(렉시컬 환경)에 외부 렉시컬 환경 참조를 통해 연결되어있다. 상위 스코프를 찾을 수 있는 이유이다.
>
> ---
>
> 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조 값 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정된다. 이것이 렉시컬 스코프이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/40601b90-08c9-4854-be88-6e6bd3b3e2d3/Untitled.png)

핵심은 함수 정의가 평가되어 함수 객체가 생성될때 정해진다라는 것이다.

함수는 자신의 내부슬롯에 [[Environment]] 에 자신이 정의된 환경 상위 스코프를 저장한다.

여기서 [[Environment]]와 **외부 렉시컬 환경참조의** 이 헷깔릴 수 있다. 정리를하자면

1.  함수가 정의 됬을때 상위 스코프의 정보가 담겨있는게 [[Environment]]내부슬롯이다.
2.  함수가 호출 됬을때 렉시컬 환경의 상위 렉시컬 환경을 참조하는게 **외부 렉시컬 환경참조**이다.
3.  함수가 호출 되고 실행 컨텍스트가 만들어지면 렉시컬 환경에 **외부 렉시컬 환경참조** 값은 함수의 [[Environment]]내부슬롯을 참조한다.

> 📒 결론
>
> 평가와 선언될때 [[Environment]]내부슬롯에 상위 렉시컬 환경이 저장이되고 호출 됬을때 렉시컬 환경의 외부 렉시컬 환경 참조 값을 내부슬롯을 보고 값을 넣는다.

---

```jsx
const x = 1;

function foo() {
  const x = "bar의 상위 스코프는 foo이다.";
  function bar() {
    console.log(x);
  }
  return bar;
}

const bar = foo();
bar(); // bar의 상위 스코프는 foo이다.
```

실행을 해보면 foo함수는 bar를 리턴을한다. foo함수는 bar를 리턴을하고 함수의 생명주기는 끝이났다. 하지만 bar를 호출하게되면 foo의 지역변수 x를 참조 할 수 있게된다.

이처럼 외부함수보다 중첩함수가 더 오해 유지되는 경우 중첩함수는 이미 생명주기가 종료한 외부함수의 변수를 참조할 수 있다. 이러한 중첩함수를 클로저라고 한다.

> foo함수의 생명주기가 끝나고 실행컨텍스트가 제거가 되어도 bar함수의 클로저로 인해 foo함수의 렉시컬 환경은 소멸하지 않고 살아있다. 메모리에 남아있다라는 소리이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/012ffb1f-cc3a-42ba-96d1-db70738e0827/Untitled.png)

상위 스코프의 어떤 식별자도 참조하지 않는 함수는 클로저가 아니다. 참조를 하지않는데 클로저를 만들어버린다면 메모리 낭비이다.

```jsx
const x = 1;

function foo() {
  const x = "bar는 클로저가 맞지만 부적합하다.";
  function bar() {
    console.log(x);
  }
  bar();
}

foo();
```

위에 예제에서는 bar함수는 클로저가 맞긴하다. 하지만 보통의 클로저는 외부함수 생명주기보다 중첩함수의 생명주기가 길었을때 클로저라고 말한다. 지금 예제에서는 외부함수 중첩함수의 생명주기가 똑같다.

> 📒 클로저 결론
> 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에만 클로저이다.

---

상위 스코프에는 식별자가 x,y가 있고 참조하고 있는 x를 자유변수라고 한다. 자바스크립트엔진은 클로저가 참조 하지않는 식별자에는 기억하지 않는다. 불필요한 메모리 점유를 방지한다.

---

### 클로저를 이용한 정보은닉 / 캡슐화

```jsx
let num = 0;

const increase = () => {
  return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

위 코드는 정상적으로 잘 작동한다. 하지만 num 변수는 전역변수로 노출이 되어있어서 개발자가 모르는곳에서 임의로 변경이 되어 옳바른 결과가 안 나오는 `버그가 유발` 될 수 있다.

---

1. num 변수의 값은 inscrease 함수가 호출 되기전에는 변경되지않아야 된다.
2. num 변수의 값은 inscrease 함수만 변경 가능하다.

위에 조건으로 코드를 수정해보자. 이때 클로저를 이용하면 num변수를 `은닉` \*\*\*\*할 수 있다.

---

```jsx
const increase = (() => {
  let num = 0;
  return function inner() {
    return ++num;
  };
})();

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

즉시실행 함수를 사용하여 렉시컬 환경을 만들고 inner함수를 반환하여 상위 스코프(즉시실행 함수 렉시컬 환경)를 기억 할 수 있도록 num변수를 참조하여 클로저를 생성했습니다.

<aside>
📌 이처럼 클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용한다.

</aside>

---

### 클로저를 이용한 counter

```jsx
const counter = (() => {
  let num = 0;
  return {
    inscrease() {
      return ++num;
    },
    decrease() {
      return --num < 0 ? 0 : num;
    },
  };
})();
```

증가,감소 메소드가 있는 객체를 반환한다. 이때 num변수는 은닉이 된다. 리턴값이 객체 리터럴이여서 렉시컬환경은 만들어지지 않는다. inscrease, descreas의 `[[Environment]]`는 즉시실행 함수의 렉시컬 환경(상위스코프) 참조값이 들어있다. inscrease, descreas가 호출이 되면 ORE에는 Environment의 담겨있는 값을 사용하여 값을 채운다.
