🧑‍🎓 이번 장에 들어가기 전에 간단히 개념을 알기 위해 표로 정리 해 보았다.

| 타입     | 메모리에 저장되는 값      | 저장된 값 변경 유무 |
| -------- | ------------------------- | ------------------- |
| 원시타입 | 원시 값                   | 무(immutable)       |
| 객체타입 | 객체가 저장된 메모리 주소 | 유(mutable)         |

⭐ 다른 변수에 할당을 한다면 `원시 타입`은 원시 값이 복사 되어 전달되고 `객체 타입`은 객체가 저장된 메모리 주소가 복사 되어 전달 된다.

---

### 원시값

🔥 **1.** **변경 불가능한 값**

- 메모리에 할당된 값을 다시 수정 할 수 없는 읽기 전용이다.
- 식별자에는 값이 저장된 메모리 주소가 들어가는 것이다. 이것은 객체타입을 할당한 식별자도 동일하다.

<aside>
📌 **여기서 핵심은 메모리에 할당된 값을 변경 할 수 없어서 불변이라는 표현을 했지 변수에 할당된 값(메모리 주소)을 변경 불가능하다는 것이 아니다. 재할당을 통해 새로운 메모리 주소를 넣을 수 있다.**

</aside>

```jsx
const o = {};
o.a = 1;
console.log(o); // { a : 1 }
```

⭐⭐ ⭐ const는 상수이다. 여기서 중요한 것은 메모리에 저장된 값이 상수 개념을 갖는다는게 아니고 식별자에 한번 할당된 메모리 주소를 더 이상 못바꾼다(재할당 금지)라는 개념으로 상수인것이다.

```jsx
var score;
score = 80;
score = 90;
```

원시값을 할당한 변수에 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시값을 저장 후 새로운 메모리 공간을 변수에 할당한다.

```jsx
var score;
score = 80;
score = 80;
```

동일한 원시값을 재할당하여도 늘 새로운 메모리를 생성하고 거기에 값을 할당한다.

원본 값을 변경 할 수 없는 특성을 불변성이라고 한다.

⭐⭐ ⭐ **불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법은 없다.**

---

🔥 **2. 문자열과 불변성**

문자열 타입은 2바이트의 메모리 공간을 갖는다. 숫자는 8바이트

다른 언어의 문자열은 참조타입이다. 하지만 자바스크립트의 문자열은 원시타입을 제공한다.

```jsx
var str = "heeellll";
str = "world";
```

첫줄 str에는 heelll 값이 저장된 메모리를 바라본다. 두번째 줄에서 재할당을 하면서 새로운 메모리를 생성하고 world를 할당하고 str은 world가 저장된 메모리 주소를 바라보게 된다. GC가 메모리를 회수하지 않았다면 메모리에는 heeelll와 world 둘 다 있을 것이다. 문자열은 유사 배열 객체이면서 이터러블이다.

---

🔥 **3. 값에 의한 전달**

```jsx
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80
```

score의 할당된 80을 copy 변수에 할당 했다 이때 copy에는 score에 할당된 원시 값이 복사되어 전달 된다. 이것을 값에 의한 전달이라고한다.

⭐⭐ ⭐ **score와 copy에는 동일한 원시 값이 저장되어 있다. 값은 80이지만 다른 메모리 공간에 저장된 별개의 값이다.**

중간에 score에 100이 재할당 되었다. 이때 score와 copy는 별개의 메모리 공간에 값이여서 서로 영향을 주지않는다.

식별자는 메모리 주소에 붙인 이름이라고 할 수 있다. **이처럼 `갑의 의한 전달` 도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다. 단 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.**

### 객체

객체는 동적으로 추가와 삭제가 가능하다 프로퍼티 값에도 제약이 없다 그래서 객체타입은 메모리 공간 크기를 사전에 정해 둘 수없다.

<aside>
📌 **자바스크립트 객체는 프로퍼티 키를 인덱스로 사용한 해시테이블과 유사하다.
다른 객체지양 프로그래밍 언어들은 정의된 클래스를 기반으로 인스턴스를 생성하고 동적으로 프로퍼티를 추가 삭제 할 수 없다 정의 된 클래스를 보고 메모리를 유추 할 수 있다. 유저입장에서는 자바스크립트의 방식이 매우 편리하지만 컴퓨터 입장에서는 비용도 많이들고 비효율적인 방식이다.**

</aside>

---

🔥 **1. 변경 가능한 값**

```jsx
var person = {
  name: "lee",
};
console.log(person); // { name : 'lee' }
```

객체 타입은 변경 가능한 값(mutable value)이다. person 식별자에는 생성된 객체가 실제로 저장된 메모리 공간 주소가 저장되어있다. 이를 참조 값이라고 한다. 정리 해보면 메모리에 할당 된 값이 메모리 주소인 것이다.

```jsx
person.name = "kim";
person.address = "서울";
```

객체 타입은 재할당 없이 메모리를 참조하여 프로퍼티를 동적으로 추가 갱신 삭제가 가능하다.

<aside>
📌 **객체는 다른 변수에 할당 시 왜 새로운 값을 생성하지 않을까?**
객체를 메모리에 할당하는 건 컴퓨터 입장에서는 원시 값을 할당 하는거에 비해 엄청난 비용이 드는 행위이다. 메모리의 효율적 소비가 어렵고 성능이 나빠진다.  
그래서 다른 변수에 할당 시 동일한 메모리 값을 준다. 여러 개의 식별자가 하나의 객체를 공유 할 수 있다는 것이다.

</aside>

---

👨‍🎓 **얕은 복사 와 깊은복사**

```jsx
const o = { x: [{ z: { y: 1 } }, { z: 1 }, { z: 1 }] };

// 얕은 복사
const c1 = { ...o };
console.log(c1 === o);
console.log(c1.x === o.x);
const c = deepCopy(o);
// 깊은 복사
console.log(o.x[0].z === c.x[0].z);
```

| 얕은 복사 | 한 단계까지만 불변성을 유지하고 중첩된 객체는 불변성을 유지 하지않는다. |
| --------- | ----------------------------------------------------------------------- |
| 깊은 복사 | 객체 안에 중첩되어 있는 객체까지 모두 불변성을 유지하는 것을 말한다.    |

🔥 **2. 참조에 의한 전달**

```jsx
const person = {
  name: "lee",
};
const copy = person;
console.log(copy.name); // lee
person.name = "kim";
console.log(copy.name); // kim
// 두 개의 식별자가 하나의 객체를 공유하여서 copy의 값도 변경 되었다.
console.log(person === copy); // true
```

person 식별자에 값(메모리 주소)를 copy 식별자에 할당하면 참조 값이 복사되어 전달 된다. 이를 참조에의한 전달이라 한다.

**위에 코드가 의미하는 건 두 개의 식별자가 하나의 객체를 공유한다는 것이다.**

<aside>
💡 값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.

</aside>

자바스크립트에는 참조에 의한 전달은 존재하지 않고 값에 의한 전달만 존재한다고 말할 수 있다.(메모리도 값이라고 생각하면 이해가된다.)
